---
title: Core Library
description: Explore the core library of Butterfly
---

## Introduction

The Core Library provides foundational tools and helpers designed to maintain a beautiful and
well-structured Flutter codebase. It operates independently from user-specific logic, making it safe
to use even without the Auth Library.

One of the central pieces in this library is the `CoreService` class. Originally called
`FrameworkService`, it was renamed to avoid naming collisions with Flutter's internal APIs.

In Butterfly, services that should be extended in your project are typically prefixed with `Base`.
In this case, the actual base class is called `BaseCoreService`. When you run `butterfly init`, a
file named `core.dart` is generated inside the `services` folder. It defines your project-specific
`CoreService` class that extends `BaseCoreService`.

This `CoreService` acts as the bridge to features provided by the Core Library, including:

- Global error handling
- Theme switching support
- Full-screen loading UI

> **Can you skip using `CoreService`?**
> Technically yes ‚Äî but you'd miss out on those features. We strongly recommend keeping it in place.

## üîÅ `enqueue()` Helper

The `enqueue()` function is a utility provided by the Butterfly Core library that allows you to
safely schedule UI updates after the widget has completed its build phase. It is introduced via a
mixin, making it usable in any `State` class without requiring inheritance or framework-specific
widgets.

Unlike `WidgetsBinding.instance.addPostFrameCallback`, `enqueue()` manages a dedicated task queue,
allowing multiple UI update tasks to be queued and executed sequentially. This ensures clean and
predictable behavior without risking rendering errors like `setState() called during build`.

Key Features:
- Ensures the widget is still mounted before executing your callback
- Runs only after the current build() phase finishes
- Manages a FIFO queue so multiple callbacks don‚Äôt interfere
- Prevents: setState() or markNeedsBuild() called during build

This is especially useful for state updates that would normally be placed in initState(), but might
trigger UI rendering errors if run too early.

**Example Usage:**

Extend your `State` class with the `TaskQueueMixin` to enable the `enqueue()` functionality:

```dart
class MyWidgetState extends State<MyWidget> { // [!code --]
class MyWidgetState extends State<MyWidget> with TaskQueueMixin { // [!code ++]
  @override
  void initState() {
    super.initState();

    enqueue(() {
      // Your post-build UI update logic here
    });
  }
}
```


<Tabs> <TabItem label="Butterfly" value="butterfly">
```dart
@override
void initState() {
  super.initState();

  // Fetch user data asynchronously
  apiService.getRandomUser().then((user) {
    // ‚ùó Directly updating state here may cause errors if the widget is still building
    // ref.read(userProvider.notifier).setUser(user);

    // ‚úÖ Safely schedule the state update after the build phase
    enqueue(() {
      ref.read(userProvider.notifier).setUser(user);
    });
  });

  // Schedule additional UI updates
  enqueue(() {
    ref.read(userProvider.notifier).UpdateRandomQuote();
  });

  enqueue(() {
    ref.read(themeProvider.notifier).checkDarkMode();
  });
}
```
- The `apiService.getRandomUser()` call fetches user data asynchronously.
- Instead of updating the state immediately upon data retrieval‚Äîwhich might occur during the
widget's build phase and lead to errors‚Äîwe use `enqueue()` to schedule the state update safely after
the build completes.
- Additional UI updates, such as fetching user data and checking the theme mode, are also scheduled
using `enqueue()` to ensure they execute in the correct order and at the appropriate time.

<Info> For simplicity, this example uses the `.then` syntax. In practice, consider extracting the
initialization logic into a separate method and calling it from `initState()` for better readability
and maintainability. </Info>

</TabItem> <TabItem label="Native" value="native">
```dart
@override
void initState() {
  super.initState();

  WidgetsBinding.instance.addPostFrameCallback((_) {
    if (mounted) {
      ref.read(userProvider.notifier).fetch();

      // ‚ùó Adding another task here risks running both at the same frame
      // or calling setState during build if nested in rebuilds.
      // If needed, reuse the WidgetsBinding.instance.addPostFrameCallback
      // in this callback
    }
  });
}
```
- You‚Äôll need to manually guard `mounted`
- Cannot queue multiple tasks ‚Äî hard to control the execution order
- Prone to build-time errors if used incorrectly
 </TabItem> </Tabs>


 This helper simplifies complex post-frame logic and ensures UI updates are safe, sequential, and
 clean.

 ##